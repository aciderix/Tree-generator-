import * as THREE from 'three';
import { mergeGeometries, mergeVertices } from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { TreeConfig } from '../types';

// --- UTILITAIRES DE MATHS ET GÉOMÉTRIE ---

class Constants {
    static CAMERA_SENSITIVITY = 0.3;
    static MIN_BRANCH_RADIUS = 0.05;
    static X_AXIS = new THREE.Vector3(1, 0, 0);
    static Y_AXIS = new THREE.Vector3(0, 1, 0);
    static Z_AXIS = new THREE.Vector3(0, 0, 1);
    static UP = new THREE.Vector3(0, 1, 0);
    static SIDE = new THREE.Vector3(1, 0, 0);
    static DOWN = new THREE.Vector3(0, -1, 0);
    static EMPTY_QUATERNION = new THREE.Quaternion();
    static EPSILON = 1e-6;
}

class MathHelper {
    static degToRad(deg: number): number {
        return THREE.MathUtils.degToRad(deg);
    }
}

class QuaternionHelper {
    static influenceQuaternion(quat: THREE.Quaternion, currentVec: THREE.Vector3, targetVec: THREE.Vector3, amount: number): THREE.Quaternion {
        let rotation = new THREE.Quaternion().setFromUnitVectors(currentVec, targetVec);
        rotation = new THREE.Quaternion().slerp(rotation, amount);
        quat.multiplyQuaternions(rotation, quat);
        return rotation;
    }
    
    static qRotateY(quat: THREE.Quaternion, angleDeg: number): THREE.Quaternion {
        const rot = new THREE.Quaternion();
        rot.setFromAxisAngle(Constants.Y_AXIS, MathHelper.degToRad(angleDeg));
        return quat.multiply(rot);
    }

    static qRotateZ(quat: THREE.Quaternion, angleDeg: number): THREE.Quaternion {
        const rot = new THREE.Quaternion();
        rot.setFromAxisAngle(Constants.Z_AXIS, MathHelper.degToRad(angleDeg));
        return quat.multiply(rot);
    }
    
    static qRotateX(quat: THREE.Quaternion, angleDeg: number): THREE.Quaternion {
        const rot = new THREE.Quaternion();
        rot.setFromAxisAngle(Constants.X_AXIS, MathHelper.degToRad(angleDeg));
        return quat.multiply(rot);
    }
}

class GeometryHelper {
    static vertexArrToBuffer(verts: THREE.Vector3[]): number[] {
        let arr: number[] = [];
        for (let i = 0; i < verts.length; i++) {
            arr.push(verts[i].x);
            arr.push(verts[i].y);
            arr.push(verts[i].z);
        }
        return arr;
    }

    static computeNodeData(grid: Map<string, any[]>, position: THREE.Vector3, radius: number, strength: number, cellSize: number) {
        if (grid.size === 0) {
            return { vector: new THREE.Vector3(0, 1, 0), shadePoints: 0 };
        }
        const vec = new THREE.Vector3(0, 0, 0);
        let count = 0;
        let shadePoints = 0;
        
        const cx = Math.floor(position.x / cellSize);
        const cy = Math.floor(position.y / cellSize);
        const cz = Math.floor(position.z / cellSize);
        
        const checkDist = Math.max(radius, strength);
        const cellsToCheck = Math.ceil(checkDist / cellSize);

        for (let x = cx - cellsToCheck; x <= cx + cellsToCheck; x++) {
            for (let y = cy - cellsToCheck; y <= cy + cellsToCheck; y++) {
                for (let z = cz - cellsToCheck; z <= cz + cellsToCheck; z++) {
                    const key = `${x}_${y}_${z}`;
                    const nodes = grid.get(key);
                    if (nodes && nodes.length > 0) {
                        for (const node of nodes) {
                            const dist = position.distanceTo(node.end);
                            if (dist < radius) {
                                const dir = new THREE.Vector3().subVectors(node.end, position).normalize();
                                vec.add(dir);
                                count++;
                            }
                            if (dist < strength) shadePoints++;
                        }
                    }
                }
            }
        }
        
        if (radius > 0 && count > 0) vec.divideScalar(count).normalize();
        vec.negate();
        return { vector: vec, shadePoints };
    }
}

class MeshGenerator {
    static flareTaperImproved(layer: number, params: any): number {
        // Logique de l'évasement à la base du tronc
        const decay = 1 / params.trunkFlareTaper;
        return Math.pow(2, -decay * layer) * params.trunkFlareWidth;
    }

    static createVertexPlane(center: THREE.Vector3, rotation: THREE.Quaternion, radius: number, segments: number, params: any, nextDir?: THREE.Vector3): THREE.Vector3[] {
        const vertices: THREE.Vector3[] = [];
        const step = 360 / segments;
        
        for (let deg = 0; deg <= 361; deg += step) {
            const rad = MathHelper.degToRad(deg);
            const v = new THREE.Vector3(radius * Math.cos(rad), 0, radius * Math.sin(rad));
            let rotClone = rotation.clone();
            
            if (nextDir) {
                const up = new THREE.Vector3(0, 1, 0);
                up.applyQuaternion(rotation);
                QuaternionHelper.influenceQuaternion(rotClone, up, nextDir, 0.5);
            }
            
            v.applyQuaternion(rotClone);
            v.add(center);
            vertices.push(v);
        }
        return vertices;
    }

    static generateIndices(totalVerts: number, segments: number): number[] {
        let indices: number[] = [];
        const stride = segments + 1;
        for (let i = 0; i < totalVerts - stride - 1; i++) {
             indices.push(i + stride + 1, i + 1, i);
             indices.push(i, i + stride, i + stride + 1);
        }
        return indices;
    }
    
    static generateContinuousUVs(vertices: THREE.Vector3[], segments: number, vStart: number, vEnd: number): number[] {
        const uvs: number[] = [];
        // Nous avons 2 anneaux : Start et End
        // Ring 0 correspond à vStart
        // Ring 1 correspond à vEnd
        
        for (let r = 0; r < 2; r++) {
            const vCoord = r === 0 ? vStart : vEnd;
            for(let s=0; s<=segments; s++) {
                const uCoord = s / segments;
                uvs.push(uCoord, vCoord);
            }
        }
        return uvs;
    }
}

// --- GÉNÉRATEUR DE NOMBRES ALÉATOIRES ---

class PRNG {
    private seed: number;
    constructor(str: string) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
            h = Math.imul(h ^ str.charCodeAt(i), 16777619);
        }
        this.seed = h;
    }

    next(): number {
        this.seed += 0x6D2B79F5;
        let t = this.seed;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

class GlobalRNG {
    static RNG: PRNG;
    
    static SET_SEED(seed: string | number) {
        this.RNG = new PRNG(seed.toString());
    }

    static GET_RANDOM_FLOAT(min: number, max: number): number {
        if (min === 0 && max === 0) return 0;
        return this.RNG.next() * (max - min) + min;
    }

    static GET_RANDOM_INT(min: number, max: number): number {
        if (min === 0 && max === 0) return 0;
        return Math.floor(this.RNG.next() * (max - min + 1)) + min;
    }

    static RAND_UNITVEC(): THREE.Vector3 {
        return new THREE.Vector3(
            this.GET_RANDOM_FLOAT(-1, 1),
            this.GET_RANDOM_FLOAT(-1, 1),
            this.GET_RANDOM_FLOAT(-1, 1)
        ).normalize();
    }
}

// --- SYSTÈME DE GRILLE ET LUMIÈRE ---

class GridMap {
    static getGridKey(pos: THREE.Vector3, size: number): string {
        const x = Math.floor(pos.x / size);
        const y = Math.floor(pos.y / size);
        const z = Math.floor(pos.z / size);
        return `${x}_${y}_${z}`;
    }

    static addNode(map: Map<string, any[]>, size: number, item: any, pos: THREE.Vector3) {
        const key = this.getGridKey(pos, size);
        if (!map.has(key)) map.set(key, []);
        map.get(key)!.push(item);
    }
    
    static removeNode(map: Map<string, any[]>, key: string, item: any) {
        const list = map.get(key);
        if (list) {
            const idx = list.indexOf(item);
            if (idx !== -1) list.splice(idx, 1);
            if (list.length === 0) map.delete(key);
        }
    }
    
    static updateNode(map: Map<string, any[]>, size: number, oldPos: THREE.Vector3, item: any) {
        const oldKey = this.getGridKey(oldPos, size);
        const newKey = this.getGridKey(item.end, size);
        
        if (oldKey !== newKey) {
            this.removeNode(map, oldKey, item);
            this.addNode(map, size, item, item.end);
        }
    }
}

// --- LOGIQUE DE L'ARBRE ---

interface Segment {
    start: THREE.Vector3;
    end: THREE.Vector3;
    direction: THREE.Quaternion;
    directionVector: THREE.Vector3;
    foliageSize: number;
    iteration: number;
    layer: number;
    thicknessGrowth: number;
    thicknessGrowthFactor: number;
    length: number;
    energyProduction: number;
    energyProductionLastComputed: number;
    weightTorque: number;
    weightTorqueSag: number;
    weightTorqueCOM: THREE.Vector3;
    weightTorqueCOMAmount: number;
    auxinLevel: number;
    auxinSource: any;
    deltaTotal?: THREE.Quaternion;
}

class Branch {
    tree: Tree;
    properties: any;
    iteration: number;
    layer: number;
    id: number;
    
    lightLevel: number = 0;
    brightDirection: THREE.Vector3 = new THREE.Vector3(0,1,0);
    apicalInhibitance: number = 0;
    growthAccumulator: number = 0;
    
    parent: Branch | null = null;
    parentStartIndex: number = 0;
    
    segments: Segment[] = [];
    children: Branch[] = [];
    
    isDead: boolean = false;
    shouldRemove: boolean = false;
    hide: boolean = false;
    collided: boolean = false;
    
    branchRotationControl: number;
    position: THREE.Vector3;
    prevPosition: THREE.Vector3;
    direction: THREE.Quaternion;
    directionVector: THREE.Vector3;

    constructor(tree: Tree, properties: any, iteration: number = 0, layer: number = 1) {
        this.tree = tree;
        this.properties = properties;
        this.iteration = iteration;
        this.layer = layer;
        this.id = tree.createGrowthId();
        
        this.branchRotationControl = GlobalRNG.GET_RANDOM_INT(0, 359);
        this.position = new THREE.Vector3();
        this.prevPosition = new THREE.Vector3();
        this.direction = new THREE.Quaternion();
        this.directionVector = new THREE.Vector3(0, 1, 0);
    }

    grow() {
        if (this.isDead) return;

        this.properties.apicalDominance *= this.properties.apicalDominanceDecay;

        // 1. Drop if shaded (not implemented in detail here but placeholder)
        if (this.lightLevel < this.properties.dropShadedGrowths && this.children.length === 0) {
            this.remove();
            return;
        }

        // 2. Drop low branches
        if (this.position.y < this.properties.dropLowGrowth && this.tree.age > this.properties.dropLowGrowth * 2) {
             this.remove();
             return;
        }

        // Calculate growth potential
        let vigor = 1;
        if (this.parent) {
            vigor *= Math.pow(this.lightLevel, this.properties.prioritizeBright);
        }
        vigor *= (1 - this.apicalInhibitance);
        
        this.growthAccumulator += vigor;

        let hasGrown = false;
        while (this.growthAccumulator >= 1) {
            this.growthAccumulator -= 1;
            hasGrown = true;
        }

        this.propagateResources(hasGrown ? 1 : 0);

        if (!hasGrown) return;

        // --- DIRECTION CALCULATION ---
        this.updateGrowthControl();

        const seekSun = this.properties.seekSun ?? 0;
        const apicalSeek = this.properties.apicalSeekSun ?? 0;
        const verticalFactor = seekSun * (1 - apicalSeek + apicalSeek * this.apicalInhibitance);
        
        QuaternionHelper.influenceQuaternion(this.direction, this.directionVector, Constants.UP, verticalFactor);
        QuaternionHelper.influenceQuaternion(this.direction, this.directionVector, this.brightDirection, this.properties.seekLight);
        QuaternionHelper.influenceQuaternion(this.direction, this.directionVector, GlobalRNG.RAND_UNITVEC(), this.properties.gnarl);
        
        const nodeData = GeometryHelper.computeNodeData(this.tree.nodeGrid, this.position, 3, this.properties.growthShyness, this.tree.nodeGridCellSize);
        QuaternionHelper.influenceQuaternion(this.direction, this.directionVector, nodeData.vector, this.properties.growthShyness);

        const segment = this.createSegment();
        this.segments.push(segment);
        this.tree.addNodeGridPoint(segment);
        this.layer++;

        this.createNewGrowths();
    }

    propagateResources(resource: number) {
         for(let i = this.segments.length - 1; i>=0; i--) {
             const seg = this.segments[i];
             seg.thicknessGrowth += resource * 0.1;
             
             // Apply Flare Taper logic from original
             if(seg.iteration === 0) {
                 // Using the simplified formula from MeshGenerator
                 seg.thicknessGrowth += MeshGenerator.flareTaperImproved(seg.layer, this.properties);
             }
         }
         if(this.parent) {
             this.parent.propagateResources(resource);
         }
    }

    createNewGrowths() {
        if (this.segments.length <= 1) return;
        
        // Use random chance for branching
        if(GlobalRNG.GET_RANDOM_INT(0, 100) > 85) { 
            const count = this.properties.whorls;
            for (let i = 0; i < count; i++) {
                const props = JSON.parse(JSON.stringify(this.properties));
                const startPos = this.position.clone();
                
                const childDir = this.direction.clone();
                QuaternionHelper.qRotateY(childDir, this.branchRotationControl + (i * 360 / count));
                QuaternionHelper.qRotateZ(childDir, this.properties.branchJointAngle);

                const child = new Branch(this.tree, props, this.iteration + 1, this.layer + 1);
                child.position.copy(startPos);
                child.prevPosition.copy(this.prevPosition);
                child.direction.copy(childDir);
                
                const v = new THREE.Vector3(0, 1, 0);
                v.applyQuaternion(childDir);
                child.directionVector.copy(v);

                child.parent = this;
                child.parentStartIndex = this.segments.length - 1;
                
                this.tree.growths.push(child);
                this.children.push(child);
            }
            this.branchRotationControl += 137.5;
        }
    }

    createSegment(): Segment {
        return {
            start: this.prevPosition.clone(),
            end: this.position.clone(),
            direction: this.direction.clone(),
            directionVector: this.directionVector.clone(),
            foliageSize: this.properties.foliageSize,
            iteration: this.iteration,
            layer: this.layer,
            thicknessGrowth: 1,
            thicknessGrowthFactor: this.properties.thicknessGrowthFactor,
            length: this.properties.segmentLength,
            energyProduction: 0,
            energyProductionLastComputed: 0,
            weightTorque: 0,
            weightTorqueSag: 0,
            weightTorqueCOM: new THREE.Vector3(),
            weightTorqueCOMAmount: 0,
            auxinLevel: 0,
            auxinSource: null
        };
    }

    updateGrowthControl() {
        this.prevPosition.copy(this.position);
        const move = new THREE.Vector3(0, this.properties.segmentLength, 0);
        move.applyQuaternion(this.direction);
        this.directionVector.copy(move).normalize();
        this.position.add(move);
    }

    remove() {
        this.isDead = true;
        this.shouldRemove = true;
        for(const child of this.children) {
            child.remove();
        }
    }
}

export class Tree {
    properties: TreeConfig;
    seed: number = 0;
    age: number = 0;
    growths: Branch[] = [];
    nodeGrid: Map<string, any[]> = new Map();
    nodeGridCellSize: number = 3;
    idIndex: number = -1;

    structureMesh: THREE.Mesh | null = null;
    foliageMesh: THREE.Mesh | null = null;
    fruitMesh: THREE.Mesh | null = null;

    constructor(config: TreeConfig) {
        this.properties = JSON.parse(JSON.stringify(config));
    }

    createGrowthId() {
        return ++this.idIndex;
    }

    setSeed(s: number) {
        this.seed = s;
        GlobalRNG.SET_SEED(s);
    }

    prepare() {
        const trunkParams = this.properties.parameters;
        const numTrunks = trunkParams.numTrunks;
        
        // Multi-trunk logic restored from original 'hl' concept but simplified
        if (numTrunks > 1) {
             const spread = trunkParams.trunkSpread || 5;
             for (let i = 0; i < numTrunks; i++) {
                 const trunk = new Branch(this, trunkParams);
                 // Random placement within spread radius
                 const angle = (i / numTrunks) * Math.PI * 2;
                 const radius = GlobalRNG.GET_RANDOM_FLOAT(0.5, spread);
                 const x = Math.cos(angle) * radius;
                 const z = Math.sin(angle) * radius;
                 
                 trunk.position.set(x, 0, z);
                 // Tilt outward slightly
                 QuaternionHelper.influenceQuaternion(trunk.direction, Constants.UP, new THREE.Vector3(x, 10, z).normalize(), 0.1);
                 
                 this.growths.push(trunk);
             }
        } else {
             const trunk = new Branch(this, trunkParams);
             trunk.position.set(0, 0, 0);
             this.growths.push(trunk);
        }
    }

    growOneStep() {
        const count = this.growths.length;
        
        // Fake light simulation
        for(const growth of this.growths) {
            if(growth.isDead) continue;
            growth.lightLevel = Math.min(1, (growth.position.y / 10) + GlobalRNG.GET_RANDOM_FLOAT(0.2, 0.5));
            growth.brightDirection = new THREE.Vector3(0, 1, 0).add(GlobalRNG.RAND_UNITVEC().multiplyScalar(0.2)).normalize();
        }

        for (let i = 0; i < count; i++) {
            this.growths[i].grow();
        }

        this.age++;
    }

    addNodeGridPoint(segment: Segment) {
        GridMap.addNode(this.nodeGrid, this.nodeGridCellSize, segment, segment.end);
    }

    buildMesh(): THREE.Group {
        const group = new THREE.Group();
        
        const woodGeometries: THREE.BufferGeometry[] = [];
        const foliageGeometries: THREE.BufferGeometry[] = [];

        for(const growth of this.growths) {
            if(growth.shouldRemove && growth.segments.length === 0) continue;

            const branchGeoms = this.assembleBranchGeometry(growth);
            woodGeometries.push(...branchGeoms);

            if (growth.iteration > 0 && !growth.isDead) {
                const threshold = Math.max(1, this.properties.parameters.foliageThreshold);
                const lastSegs = growth.segments.slice(-threshold);
                for(const seg of lastSegs) {
                    const leaf = this.spawnFoliage(seg);
                    if(leaf) foliageGeometries.push(leaf);
                }
            }
        }

        const scale = this.properties.parameters.scaleFactor || 1;
        const scaleMatrix = new THREE.Matrix4().makeScale(scale, scale, scale);

        // Merge Wood
        if(woodGeometries.length > 0) {
            let mergedWood = mergeGeometries(woodGeometries, false);
            if (mergedWood) {
                 // IMPORTANT: Fusionner les sommets par proximité pour lisser le shading
                 // Cela élimine l'aspect "facetté" entre les segments
                 mergedWood = mergeVertices(mergedWood);
                 mergedWood.computeVertexNormals();
                 
                 mergedWood.applyMatrix4(scaleMatrix);
                 const material = new THREE.MeshStandardMaterial({ 
                     color: 0x5d4037, 
                     roughness: 0.9,
                     name: 'Bark'
                 });
                 this.structureMesh = new THREE.Mesh(mergedWood, material);
                 this.structureMesh.castShadow = true;
                 this.structureMesh.receiveShadow = true;
                 group.add(this.structureMesh);
            }
        }

        // Merge Foliage
        if(foliageGeometries.length > 0) {
            const mergedLeaves = mergeGeometries(foliageGeometries, false);
            if(mergedLeaves) {
                mergedLeaves.computeVertexNormals();
                mergedLeaves.applyMatrix4(scaleMatrix);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x4caf50, 
                    side: THREE.DoubleSide,
                    roughness: 0.6,
                    name: 'Leaves'
                });
                this.foliageMesh = new THREE.Mesh(mergedLeaves, material);
                this.foliageMesh.castShadow = true;
                this.foliageMesh.receiveShadow = true;
                group.add(this.foliageMesh);
            }
        }

        return group;
    }

    assembleBranchGeometry(growth: Branch): THREE.BufferGeometry[] {
        const geoms: THREE.BufferGeometry[] = [];
        let prevRing: THREE.Vector3[] | null = null;
        let currentV = 0; // Pour assurer la continuité de la texture (UV) le long de la branche
        
        for(let i=0; i<growth.segments.length; i++) {
            const seg = growth.segments[i];
            
            let radius = Math.max(
                this.properties.parameters.minThickness,
                seg.thicknessGrowthFactor * Math.sqrt(seg.thicknessGrowth)
            );
            
            const segments = this.properties.parameters.faces;

            const nextDir = (i < growth.segments.length - 1) ? growth.segments[i+1].directionVector : undefined;

            let ringStart: THREE.Vector3[];

            if (prevRing) {
                ringStart = prevRing;
            } else {
                let startRadius = radius;
                let rotation = seg.direction;

                if(seg.layer === 1) { 
                     startRadius += MeshGenerator.flareTaperImproved(0, this.properties.parameters);
                     rotation = new THREE.Quaternion(); // Identity for base
                }
                
                ringStart = MeshGenerator.createVertexPlane(seg.start, rotation, startRadius, segments, this.properties.parameters);
            }

            // End ring of current segment (will become start ring of next segment)
            const ringEnd = MeshGenerator.createVertexPlane(seg.end, seg.direction, radius, segments, this.properties.parameters, nextDir);

            const vertices = [...ringStart, ...ringEnd];
            const indices = MeshGenerator.generateIndices(vertices.length, segments);
            
            // Calculer les UVs continus
            // On incrémente V de manière simple (1 unité par segment pour l'instant) ou proportionnelle à la longueur
            const vStart = currentV;
            const vEnd = currentV + (seg.length * 0.5); // Facteur arbitraire pour l'échelle texture
            const uvs = MeshGenerator.generateContinuousUVs(vertices, segments, vStart, vEnd);
            currentV = vEnd;

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(GeometryHelper.vertexArrToBuffer(vertices), 3));
            geometry.setIndex(indices);
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            
            geoms.push(geometry);
            
            // Store ringEnd to be used as ringStart for the next segment
            prevRing = ringEnd;
        }
        return geoms;
    }

    spawnFoliage(seg: Segment): THREE.BufferGeometry | null {
        const size = this.properties.parameters.foliageSize || 0.5;
        const geom = new THREE.PlaneGeometry(size, size);
        
        const matrix = new THREE.Matrix4();
        const quat = new THREE.Quaternion();
        quat.setFromEuler(new THREE.Euler(
            GlobalRNG.GET_RANDOM_FLOAT(0, Math.PI),
            GlobalRNG.GET_RANDOM_FLOAT(0, Math.PI),
            GlobalRNG.GET_RANDOM_FLOAT(0, Math.PI)
        ));
        
        const pos = seg.end.clone().add(GlobalRNG.RAND_UNITVEC().multiplyScalar(0.2));
        const scale = new THREE.Vector3(1, 1, 1);
        
        matrix.compose(pos, quat, scale);
        geom.applyMatrix4(matrix);
        
        return geom;
    }
}

export async function generateTreeAsync(config: TreeConfig, onProgress: (p: number, msg: string) => void): Promise<THREE.Group> {
    const tree = new Tree(config);
    tree.setSeed(config.seed);
    tree.prepare();

    const totalYears = config.years;
    for(let y=0; y<totalYears; y++) {
        tree.growOneStep();
        onProgress(Math.floor(((y+1)/totalYears)*100), `Croissance année ${y+1}/${totalYears}`);
        await new Promise(resolve => setTimeout(resolve, 10)); 
    }

    onProgress(100, "Génération du maillage...");
    await new Promise(resolve => setTimeout(resolve, 20)); 
    
    return tree.buildMesh();
}